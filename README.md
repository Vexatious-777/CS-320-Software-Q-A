# CS-320-Software-Q-A

My work in this class has shown me that there are some powerful tools at a developer's disposal that enable them to tackle potential errors within their work with ease, That is in comparison to strictly maual code review. This is due to my time learning about Junit tests and how to properly implement this testing library, when creating software.

I ensure that my code, program, or software is functional and secure by testing them all. This can be done in many ways, whether through the use of software test cases and automation or personal and persistent code review as I work on a project. If available I would also love to ask for help for manual code review from those who haven't actually gone through the process of writing therefore I can dodge any personal bias and hopefully find any errors I may have accidentally turned a blind eye to.


I interpret user needs and incorporate them into a program by first doing my best to fully comprehend what the user is asking for. If I must to gain a full understanding and the user is available I will question them directly, if I come across any requirements that I am not entirely sure of what is being asked of me. I then begin designing the software around these user needs, since more or less user needs are the foundation of any sort of "software blueprint". Which therefore incorporates the user needs into the program.


I approach designing software by first looking at the requirements for the software I intend to create. These requirements could come from an organization, End-Users, or even myself if the project is a personal one. I then plan out how to meet these requirements from an industry best standards viewpoint then, following that I begin writing the software and testing it as I go to ensure I do not waste time as I proceed. After I have come to my first finished build I will then begin testing the entire build and once I believe there are no major errors would push the build forward and look for second opionons and potential parts of the software that could be refactored and improved.
